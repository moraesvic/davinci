#!/bin/bash

### DEFINITIONS

path_to_script="$(dirname "$0")"
project_name="davinci"
default_port=5000

### HELPER FUNCTIONS

function list_files {
    # This is supposedly a better alternative to ls -1, because ls does not
    # handle well non alphanumeric file names
    #
    # https://www.shellcheck.net/wiki/SC2012

    find "$1" -maxdepth 1 -type f
}

function randint {
    # Generates a random number between [a, b[
    # Not cryptographically secure, but it doesn't have to be

    echo "$(($1 + RANDOM % $2))"
}

function prompt_yes_no {
while true ; do
        read -rp "$1 [y/n] " opt
        case $opt in
            [yY]|yes)
                return 0
                break
                ;;
            [nN]|no)
                return 1
                break
                ;;
            *)
                echo "Please select a valid option"
        esac
    done
}

function is_port_in_use {
    if ! netstat -an | grep -E "\b$1\b" | grep -iq listen ; then
        return 1
    else
        return 0
    fi
}

function get_free_port {
    # This will pick a free port in the user-defined range.
    # Check https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers

    new_port=$(randint 1024 49152)
    if is_port_in_use "$new_port" ; then
        >&2 echo "$new_port is already in use"
        get_free_port
    else
        echo "$new_port"
    fi
}

function check_existing_servers {
    # Returns how many nginx servers are configured on this machine

    sites_available=0
    # It is usually not recommended to use this configuration, but user
    # might have it. Better to check it.
    if grep -q "sites-available" /etc/nginx/nginx.conf ; then
        sites_available=$(list_files /etc/nginx/sites-available/ | wc -l)
    fi
    conf_d=$(list_files /etc/nginx/conf.d | wc -l)
    echo $((sites_available + conf_d))
}

function contains_element {
    # string, array -> boolean
    # Returns whether an array contains an element

    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1
}

function edit_conf_file {
    filename="$path_to_script/conf/project.conf"
    sed -ri "s/yourproject/${project_name}/g ; s/yourport/${port}/g" "$filename"
}

function warning {
    >&2 printf "\033[0;33m"
    >&2 printf "$1"
    >&2 echo -e "\033[0m"
}

#########################
### SUB-ROUTINES

function welcome {
    cat << EOF
# davinci <https://github.com/moraesvic/davinci>
# (C) Victor Moraes, 2021 <victor@vulpi-ideas.com>
# License GPLv3+ <https://gnu.org/licenses/gpl.html>

Welcome and thank you for downloading my project. I will guide you through \
this installation. It should take 5-10 minutes.

EOF
}

function check_dependencies {
    dependencies=("git" "npm" "psql" "nginx" "pwgen" "python")
    for arg in "${dependencies[@]}" ; do
        if [ -z "$(command -v "$arg")" ] \
            && ! dpkg -l | grep -iq "$arg" ; then
            cat << EOF

It is necessary to have $arg installed to deploy this project. Please install \
it before continuing.

EOF
            exit 1
        fi
    done
}

function clone_submodules {
    # Cadmus installer is a part of another library, written also by me.
    # In order to effectively have its files, we need to update submodules
    # recursively

    cd "$path_to_script" || exit
    git submodule update --init --recursive
}

function is_nginx_active {
    if ! systemctl is-active -q nginx ; then
        cat << EOF
nginx is not active in this machine. Please enable it with "sudo systemctl \
enable nginx && sudo systemctl start nginx". You might have to disable or \
reconfigure Apache in order to free port 80.
EOF
        exit 1
    fi
}

function installation_wizard {
    ### DECIDING THE DETAILS OF THE INSTALLATION
    # We have one problem, but many possible solutions. Each user must decide
    # what best suits them. This is just a guideline, experts can do their own
    # configuration.
    # I have tested this script in a virtual machine with Debian, but tried
    # to conform to POSIX as much as possible.

    cat << EOF

Now we will decide on the details of the installation. Please pay close \
attention, as this might change undesired settings from your computer.
EOF

    existing_servers=$(check_existing_servers)
    caveat=""
    if [[ existing_servers -eq 1 
        && -f "/etc/nginx/conf.d/default.conf" ]] ; then
            caveat="If you have just installed nginx, but never deployed a website, this might be the website which came with the installation, and it is safe to override it."
    fi

    cat << EOF

This project is meant to be deployed with nginx. Other configurations are also \
possible, but you would have to sort it manually.

We detected $existing_servers server(s) potentially running in this machine. $caveat

EOF

    if prompt_yes_no "Do you want to remove existing servers and run $project_name as the sole server on this machine? Previous servers will be backed up to /etc/nginx/conf.d.bkp/" ; then
        run_as_sole_server
    else
        multi_or_sub
    fi
}

function run_as_sole_server {
    export project_name
    export port=$default_port
    export path_to_script
    export new_conf_file="$path_to_script/conf/project.conf"

    echo "In order to make this change, you must be root. Please type in your password."
    sudo -E "$path_to_script/conf/run_as_sole_server"

    warning "\nAfter finishing, run \"npm run prod\" . Your server can be reached at http://localhost (port 80 = standard port for HTTP)"
}

function multi_or_sub {
    cat << EOF

All right, none of the previous servers will be touched. \
Now, nginx can host multiple servers in the same machine. This can be done \
either by using multiple domains, or by moving an application to a subpath \
of a primary application.

In the first case, you would end up with two locally hosted domains, e.g., \
http://firstproject.localdev and http://${project_name}.localdev 

In the second scenario, we could keep an existing application at \
http://localhost/ and the new application at http://localhost/${project_name}/

EOF

    if prompt_yes_no "Do you want to use multiple domains?" ; then
        multiple_domains
    else
        sub_application
    fi
}

function multiple_domains {
    export project_name
    export port=$(get_free_port 2> /dev/null)
    export path_to_script
    export new_conf_file="$path_to_script/conf/project.conf"

    echo "In order to make this change, you must be root. Please type in your password."
    sudo -E "$path_to_script/conf/multiple_domains"

    # Applying changes to .package.json

    sed -ri "s/^(.*)prod(.*)(PORT=[^ ]*)(.*)$/\1prod\2PORT=${port}\4/g" \
        "$path_to_script/package.json"

    warning "\nAfter finishing, run \"npm run prod\" . Your server can be reached at http://${project_name}.localdev/ (port 80 = standard port for HTTP)"

}

function sub_application {
    port=$(get_free_port 2> /dev/null)
    cat << EOF

The last possibility is to host the project as a subdirectory of a main \
website. Please pick the parent website from the list below.

EOF
    conf_files=( $(echo /etc/nginx/conf.d/*) )
    select opt in "${conf_files[@]}" ; do
        if contains_element "$opt" "${conf_files[@]}" ; then
            break;
        fi
    done

    cat << EOF

In order for this setup to work properly, you will need to launch your server \
from a different port. For that goal, nginx will direct traffic arriving at \
/$project_name to http://localhost:$port . This will be done by appending a \
location subdirective in the server block of the main website. For details \
on that code, check conf/sub_application.conf

EOF

    export path_to_script
    export port
    export project_name
    export opt

    # Changing server .conf file
    echo "In order to make this change, you must be root. Please type in your password."
    sudo -E "$path_to_script/conf/sub_application"

    # Applying changes to .package.json

    sed -ri "s/^(.*)(PUBLIC_URL=[^ ]*)(.*)$/\1PUBLIC_URL=\/${project_name}\3/g" \
        "$path_to_script/client/package.json"
    sed -ri "s/^(.*)prod(.*)(PORT=[^ ]*)(.*)$/\1prod\2PORT=${port}\4/g" \
        "$path_to_script/package.json"

    warning "\nAfter finishing, run \"npm run prod\" . Your server can be reached at http://localhost/${project_name} (port 80 = standard port for HTTP)"
}



function run_installation {
    cat << EOF

Settings were applied successfully. Now the installation per se begins. Go \
grab a coffee, it might still take around 5 minutes.

EOF

    npm i
    cd "client" || exit
    npm i
    npm audit fix
    npm run build

    ### Configuring PostgreSQL

cat << EOF

Now we will configure PostgreSQL. You might need to type in your password. \
For the database name, anything goes, but it is advised to use the name \
"$project_name" for clarity.

EOF

    cd "../install" || exit
    ./install

    cd ".." || exit
    cat << EOF

Everything should be ready for deployment. Run the server with \
"npm run prod" . Happy programming!

EOF
}

function main {
    welcome
    check_dependencies
    is_nginx_active
    clone_submodules
    installation_wizard
    run_installation
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]] ; then
    main "$@"
fi