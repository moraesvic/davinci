#!/bin/bash

### DEFINITIONS

path_to_script="$(dirname "$0")"
project_name="davinci"
default_port=5000

### HELPER FUNCTIONS

function list_files {
    find "$1" -maxdepth 1 -type f
}

function prompt_yes_no {
while true ; do
        read -rp "$1 [y/n] " opt
        case $opt in
            [yY]|yes)
                return 0
                break
                ;;
            [nN]|no)
                return 1
                break
                ;;
            *)
                echo "Please select a valid option"
        esac
    done
}

function is_port_in_use {
    # if [ -z "$(netstat -an | grep -E "\b$1\b" | grep -i listen)" ] ; then
    if netstat -an | grep -E "\b$1\b" | grep -iq listen ; then
        return 1
    else
        return 0
    fi
}

function get_free_port {
    # This will pick a free port in the user-defined range.
    # Check https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers
    #
    # This could have been done without python, for better compatibility,
    # but honestly, today python is everywhere
    new_port=$(python -c "import random ; print (random.randint(1024,49151))")
    if is_port_in_use "$new_port" ; then
        echo "$new_port is already in use"
        get_free_port
    else
        echo "$new_port"
    fi
}

function check_existing_servers {
    sites_available=0
    # It is usually not recommended to use this configuration, but user
    # might have it. Better to check it.
    # if [ -n "$(grep "sites-available" /etc/nginx/nginx.conf)" ] ; then
    if ! grep "sites-available" /etc/nginx/nginx.conf ; then
        sites_available=$(list_files /etc/nginx/sites-available/ | wc -l)
    fi
    conf_d=$(list_files /etc/nginx/conf.d | wc -l)
    echo $((sites_available + conf_d))
}

function contains_element {
    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1
}

function edit_conf_file {
    filename="$path_to_script/conf/project.conf"
    sed -ri "s/yourproject/${project_name}/ ; s/yourport/${port}/" "$filename"
}

# This excerpt will be injected to user's configuration file if s/he decides
# to install new app in a subdirectory

inject=$(cat "$path_to_script/conf/sub_application.conf")

inject_clean=$(tr '\n\t' ' ') <<< $"inject"

#########################
### WELCOME
cat << EOF
# davinci <https://github.com/moraesvic/davinci>
# (C) Victor Moraes, 2021 <victor@vulpi-ideas.com>
# License GPLv3+ <https://gnu.org/licenses/gpl.html>

Welcome and thanks for downloading my project. I will guide you through \
this installation. It should take 5-10 minutes.
EOF

#########################
### CHECKING DEPENDENCIES

dependencies=("git" "npm" "psql" "nginx" "python")
for arg in "${dependencies[@]}" ; do
    if [ -z "$(command -v "$arg")" ] ; then
        cat << EOF

It is necessary to have $arg installed to deploy this project. Please install
it before continuing.

EOF
        exit 1
    fi
done

### IS NGINX ACTIVE ?

if [[ ! "$(systemctl is-active nginx)" == "active" ]] ; then
    cat << EOF
nginx is not active in this machine. Please enable it with "sudo systemctl \
enable nginx && sudo systemctl start nginx". You might have to disable or \
reconfigure Apache in order to free port 80.
EOF
    exit 1
fi

### CLONE SUBMODULES
# Cadmus installer is a part of another library, written also by me.
# In order to effectively have its files, we need to update submodules
# recursively

cd "$path_to_script" || exit
git submodule update --init --recursive

#########################
### DECIDING THE DETAILS OF THE INSTALLATION
# We have one problem, but many possible solutions. Each user must decide
# what best suits them. This is just a guideline, experts can do their own
# configuration.
# I have tested this script in a virtual machine with Debian, but tried
# to conform to POSIX as much as possible.

cat << EOF

Now we will decide on the details of the installation. Please pay close \
attention, as this might change undesired settings from your computer.

EOF

#########################
### RUN AS THE SOLE SERVER , REMOVING POSSIBLE EXISTING SERVERS ?

existing_servers=$(check_existing_servers)
caveat=""
if [[ existing_servers -eq 1 
    && -f "/etc/nginx/conf.d/default.conf" ]] ; then
        caveat="If you have just installed nginx, but never deployed a website, this might be the website which came with the installation, and it is safe to override it."
fi

cat << EOF

This project is meant to be deployed with nginx. Other configurations are also \
possible, but you would have to sort it manually.

We detected $existing_servers running in this machine. $caveat

EOF

if prompt_yes_no "Do you want to remove existing servers and run $project_name as the sole server on this machine? Previous servers will be backed up to /etc/nginx/conf.d.bkp/" ; then

    port=$default_port

    echo "In order to make this change, you must be root. Please type in your password."
    sudo -i -u root << EOF || exit 1

mkdir /etc/nginx/conf.d.bkp 2> /dev/null
mkdir /etc/nginx/sites-available.bkp 2> /dev/null
mkdir /etc/nginx/sites-enabled.bkp 2> /dev/null

cp /etc/nginx/conf.d/* /etc/nginx/conf.d.bkp
cp /etc/nginx/sites-available/* /etc/nginx/sites-available.bkp/
cp /etc/nginx/sites-enabled/* /etc/nginx/sites-enabled.bkp/

cd "$path_to_script" || exit
edit_conf_file
cp conf/project.conf "/etc/nginx/conf.d/${project_name}.conf"
systemctl restart nginx

EOF
    
### MULTIPLE DOMAINS OR SUB-APPLICATION ?

else
    cat << EOF

All right, none of the previous servers will be touched. \
Now, nginx can host multiple servers in the same machine. This can be done \
either by using multiple domains, or by moving an application to a subpath \
of a primary application. For example, we could keep the main application at \
http://localhost/ and the new application at http://localhost/${project_name}/

EOF

### MULTIPLE DOMAINS

    if prompt_yes_no "Do you want to use multiple domains?" ; then

        port=$default_port

        echo "In order to configure multiple domains, we need to be root."
        sudo -i -u root << EOF || exit 1

cd "$path_to_script" || exit
edit_conf_file
cp conf/project.conf "/etc/nginx/conf.d/${project_name}.conf"
echo -e "127.0.0.1\t${project_name}.localdev" >> /etc/hosts
systemctl restart nginx

EOF
    else

### SUB-APPLICATION
        port=$(get_free_port)
        cat << EOF
The last possibility is to host the project as a subdirectory of a main \
website. Please pick the parent website from the list below.
EOF
        conf_files=( "$(echo /etc/nginx/conf.d/*)" )
        select opt in "${conf_files[@]}" ; do
            if contains_element "$opt" "${conf_files[@]}" ; then
                break;
            fi
        done

        sed_inject=$(sed -r "s/yourproject/${project_name}/ ; \
            s/yourport/${port}/" <<< "$inject_clean" )

        # Changing server .conf file
        echo "In order to change .conf file, we need to be root."
        sudo -i -u root << EOF || exit 1

cd "$path_to_script" || exit
sed -ri "/server[[:space:]]+\{/ a $sed_inject" "$opt"
systemctl restart nginx

EOF

        # Applying changes to .package.json

        sed -ri "s/(.*)(PUBLIC_URL=[^ ]*)(.*)/\1PUBLIC_URL=${project_name}\3/p" \
            "client/package.json"
        sed -nr "s/(.*)prod(.*)(PORT=[^ ]*)(.*)/\1prod\2PORT=${port}\4/p" \
            "package.json"
    fi
fi
    
#########################
### STARTING INSTALLATION
# Now that

npm i
cd "client" || exit
npm i
npm audit fix
npm run build

### CONFIGURING POSTGRES

cd "../install" || exit

cat << EOF

Now we will configure PostgreSQL. You might need to type in your password. \
For the database name, anything goes, but it is advised to use the name \
"$project_name" for clarity.

EOF

./install

cd ".." || exit
cat << EOF

Everything should be ready for deployment. Run the server with \
"npm run prod" . Happy programming!

EOF

